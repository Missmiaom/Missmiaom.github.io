---
layout:     post
title:      "Reactor模式以及Poco SocketReactor 源码浅析"
subtitle:   " \"notification\""
date:       2017-9-10
author:     "leiyiming"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - poco
    - C++
---

## 常见的四种IO模式

---

服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：

1. **同步阻塞IO（Blocking IO）**：同步调用阻塞IO操作
2. **同步非阻塞IO（Non-blocking IO）**：同步调用非阻塞IO操作。
3. **IO多路复用（IO Multiplexing）**：即经典的Reactor设计模式，有时也称为异步阻塞IO。
4. **异步IO（Asynchronous IO）**：即经典的Proactor设计模式，也称为异步非阻塞IO。（本文不做解释）

**同步和异步** 描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后，用户线程可以继续执行后续操作，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。

**阻塞与非阻塞** 描述的是用户线程调用请求之后的状态：阻塞是指用户线程调用请求后必须等待IO操作完成之后才能返回。非阻塞是指用户线程调用请求后无需等待IO操作完成，立即返回。

**同步阻塞IO模型**的顺序图如下图所示，用户调用read请求之后，在内核进行IO操作时被阻塞。

![1](http://leiyiming.com/img/in-post/post-poco/reactor/1.png)

**同步非阻塞IO模型**的顺序图如下图所示，用户调用read请求之后，立即返回，内核进行IO操作，此过程中用户线程需要不断地去轮询、重复请求直到请求完成。

![2](http://leiyiming.com/img/in-post/post-poco/reactor/2.png)

 **IO多路复用模型**的流程图如下图所示，模式建立在多路分离函数 `select` 基础之上，使用select可以避免同步非阻塞IO模型中轮询等待的问题。用户首先将需要监视的socket添加到select中，当数据到达时，select被激活，select函数返回，用户线程发起read请求，读取数据并继续执行。

![3](http://leiyiming.com/img/in-post/post-poco/reactor/3.png)

从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select最大的优势是**用户可以在一个线程内同时处理多个socket的IO请求**。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。



## Reactor 模式

---

在上述的多路IO复用模型中，其实用户线程可以通过辅助线程去等待select函数的返回结果，当select函数返回时，辅助线程通过消息通知用户线程，用户现场根据消息来确定就绪的socket，然后发起读写请求。**Reactor模式** 的原理就与此类似，其流程图如下：

![4](http://leiyiming.com/img/in-post/post-poco/reactor/4.png)

用户线程通过向 **Reactor** 注册事件处理器，并立即返回执行后续操作，Reactor进行调用 `select` 请求，并轮询其结果，当select函数返回即有可读的socket时，Reactor就通知用户线程，执行注册的事件处理器进行数据的读取、处理工作。其类图如下：

![5](http://leiyiming.com/img/in-post/post-poco/reactor/5.png)

**Handle**：Linux上的文件操作符，Windows上的句柄，在网络编程中通常是Socket。这里统称事件源。

**Event Demutiplexer**：多路复用器。由操作系统提供的IO多路复用机制，比如 select/epoll 。使用时用户需要将其关心的事件源注册到多路复用器上，当有事件发生时，多路复用器会从多个事件源中选出对应的事件源。

**Reactor**：事件管理的接口，提供对外的注册事件和注销事件的接口，内部则使用多路复用器注册和注销事件；运行时启动事件循环，当有事件进入就绪状态时，通知事件处理器，通过注册事件的回调函数处理事件。

**Enevt Handler**：事件处理的接口类，每个接口对应了一种类型的事件，供Reactor在相应事件发生时调用，执行相应的事件处理。



## Poco 中的 Reactor 

---

Poco中实现了Reactor模式，并整合了Acceptor-Connetor模式的服务器。下面是Poco中Reactor包的重要的类的概述：

**SocketReactor**：模式中的Reactor，提供了注册事件和注销事件的接口。

**SocketNotifier**：模式内部用于通知事件处理器的类。

**SocketAcceptor**：Acceptor-Connetor模式的Acceptor。

**SocketConnector**：Acceptor-Connetor模式的Connetor。

**ParallelSocketAcceptor**：多线程版的 SocketAcceptor，与单线程版唯一的区别在于构造和轮询中被声明和使用的 SocketReactor 对象的个数（缺省值等于处理器个数）。

**SocketNotification**：SocketReactor 生成的所有消息的基类。一共有六个派生类，分别是： ErrorNotification，IdleNotification，ReadableNotification，ShutdownNotification，TimeoutNotification，WritableNotification。



## 使用方法

---

### Reactor

**SocketReactor** 提供了注册事件和注销事件的接口，第一个参数代表了事件源，第二个参数代表了注册的事件处理器，这里使用了Poco的Observer。当某个 socket 就绪时，Observer就会接收到相应的消息，来根据不同的消息类型调用不同的回调函数进行处理。

```C++
void addEventHandler(const Socket& socket, const Poco::AbstractObserver& observer);
	/// Registers an event handler with the SocketReactor.
	///
	/// Usage:
	///     Poco::Observer<MyEventHandler, SocketNotification> obs(*this, &MyEventHandler::handleMyEvent);
	///     reactor.addEventHandler(obs);

void removeEventHandler(const Socket& socket, const Poco::AbstractObserver& observer);
	/// Unregisters an event handler with the SocketReactor.
	///
	/// Usage:
	///     Poco::Observer<MyEventHandler, SocketNotification> obs(*this, &MyEventHandler::handleMyEvent);
	///     reactor.removeEventHandler(obs);
```


### SocketAcceptor

在Poco中使用了 **SocketAcceptor** 来监听客户端的连接，其采用了经典的Acceptor-Connetor模式，将客户端服务端解耦为三个组件，分别是：**Acceptors**，**Connectors** 和 **Service Handlers**。

**SocketAcceptor 的工作原理**：它有一个重要的模板参数 **class ServiceHandler** 。构造时需要传入 SocketReactor 和  ServerSocket 对象的引用，然后向 SocketReactor 对象注册传入的 **ServerSocket** 和对 **ReadableNotification** 关心的 Observer，这个 Observer 在内部会注册一个 `onAccept` 回调函数。

当有客户端发起连接请求时，ServerSocket 被 select 选中，Observer 接收到 ReadableNotification 消息并调用 `onAccept` ，然后创建一个 **ServiceHandler** 对象。

ServiceHandler 对象的作用就是和客户端进行通信，其在Reactor模式中对应的就是Event Handler，只不过 Poco 中使用了自己的消息机制，不需要用户自己通过多态来实现消息通知，所以用户需要做的只是实现 ServiceHandler 。

下面的代码就是开启服务器的代码，分别声明一个 ServerSocket 对象，一个 SocketReactor 对象，一个 ParallelSocketAcceptor 对象，然后调用 SocketReactor 的 `run` 方法就可以了，当有客户端连接时，会自动生成一个 ServerHandler 对象处理连接。

```C++
Poco::Net::ServerSocket serverSocket(4569);

Poco::Net::SocketReactor reactor;

Poco::Net::ParallelSocketAcceptor<ServerHandler, Poco::Net::SocketReactor> acceptor(serverSocket, reactor);

reactor.run();
```



### ServiceHandler

ServiceHandler 的责任是提供处理消息的回调函数，并向 SocketReactor 注册 Observer。当对应事件发生时，SocketReactor 能根据被 select 的 socket 向某个 Observer 发出特定的消息，对应的回调函数就能够执行相应的处理。

首先，设计 ServiceHandler 时，它的构造函数必须只含有 StreamSocket 和 ServiceReactor 类型的引用参数。例如：

```C++
MyServiceHandler(const StreamSocket& socket, ServiceReactor& reactor)
```

其次，ServiceHandler 必须提供相应 SocketNotification 的 Observer 并添加回调函数，并且需要调用 SocketReactor 的 `addEventHandler` 方法来注册。这样就可以正常使用了Poco的Reactor模式了。

ServerHandler 示例声明：

```C++
class ServerHandler : public Poco::RefCountedObject {
public:
    ServerHandler(Poco::Net::StreamSocket& socket, Poco::Net::SocketReactor& reactor);
    ~ServerHandler();

    //回调函数
    void OnReadable(Poco::Net::ReadableNotification* pNf);
    void OnWriteable(Poco::Net::WritableNotification* pNf);
    void OnError(Poco::Net::ErrorNotification* pNf);
    void OnTimeout(Poco::Net::TimeoutNotification* pNf);
    void OnShutdown(Poco::Net::ShutdownNotification* pNf);
private:
    Poco::Net::StreamSocket         _socket;
    Poco::Net::SocketReactor&       _reactor;
  
    Poco::Observer<ServerHandler, Poco::Net::ReadableNotification> _or;
    Poco::Observer<ServerHandler, Poco::Net::WritableNotification> _ow;
    Poco::Observer<ServerHandler, Poco::Net::ErrorNotification>    _oe;
    Poco::Observer<ServerHandler, Poco::Net::TimeoutNotification>  _ot;
    Poco::Observer<ServerHandler, Poco::Net::ShutdownNotification> _os;
};
```

实现：

```C++
ServerHandler::ServerHandler(StreamSocket & socket, SocketReactor & reactor)
    :_logger(Poco::Logger::get("ReactorServer.ServerHandler"))
    , _socket(socket)
    , _reactor(reactor)
    , _or(*this, &ServerHandler::OnReadable)
    , _ow(*this, &ServerHandler::OnWriteable)
    , _oe(*this, &ServerHandler::OnError)
    , _ot(*this, &ServerHandler::OnTimeout)
    , _os(*this, &ServerHandler::OnShutdown)
{
    _address = socket.peerAddress().toString();

    AddReactorEventHandlers();

    _socket.setNoDelay(true);
    _socket.setBlocking(false);
}

ServerHandler::~ServerHandler()
{
    RemoveReactorEventHandlers();
}

void ServerHandler::AddReactorEventHandlers()
{
    _reactor.addEventHandler(_socket, _oe);
    _reactor.addEventHandler(_socket, _os);
    _reactor.addEventHandler(_socket, _or);
    _reactor.addEventHandler(_socket, _ow);
}

void ServerHandler::RemoveReactorEventHandlers()
{
    _reactor.removeEventHandler(_socket, _oe);
    _reactor.removeEventHandler(_socket, _os);
    _reactor.removeEventHandler(_socket, _or);
    _reactor.removeEventHandler(_socket, _ow);
}

```

至此，Poco Reactor 基本的使用方法是这些了，关键在于实现 ServerHandler 并向 SocketReactor 注册，通过 SocketAcceptor 监听客户端连接，并自动生成 ServerHandler 实例。ServerHandler 中还可以根据用户自己的需求来进行扩展，比如实现读写缓冲区，解析包，心跳等等。

具体的项目移位链接：[ReactorServer](https://github.com/Missmiaom/ReactorServer.git)



## 参考文献

---

[高性能IO模型浅析](http://www.cnblogs.com/fanzhidongyzby/p/4098546.html)

[Poco官方文档之Network Programming](https://pocoproject.org/slides/200-Network.pdf)

[[libevent之Reactor模式](http://www.cnblogs.com/xiehongfeng100/p/4820686.html)



